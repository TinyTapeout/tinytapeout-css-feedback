#lang rosette/safe

(define (bufferC a) a)
(define (notC a) (not a))

(define (andC a b) (and a b))
(define (orC a b) (or a b))
(define (xorC a b) (xor a b))
(define (nandC a b) (nand a b))

(define indices '(0 1 2 3 4))

(define (lookup name) (let ([table `((bufferC ,bufferC)
                                     (notC ,notC)
                                     (andC ,andC)
                                     (orC ,orC)
                                     (xorC ,xorC)
                                     (nandC ,nandC))])
                        (second (assoc name table))))

(define (gate-fn gate) (first gate))
(define (gate-argindices gate) (second gate))
(define (gate-destidx gate) (third gate))

(define (realise-gate gate) (list (lookup (gate-fn gate)) (gate-argindices gate) (gate-destidx gate)))

(define gates
 (map realise-gate
 '((bufferC (0) 0)
  (notC (0) 0)
  (bufferC (1) 0)
  (notC (1) 0)
  (bufferC (2) 0)
  (notC (2) 0)
  (bufferC (3) 0)
  (notC (3) 0)
  (bufferC (4) 0)
  (notC (4) 0)
  (bufferC (0) 1)
  (notC (0) 1)
  (bufferC (1) 1)
  (notC (1) 1)
  (bufferC (2) 1)
  (notC (2) 1)
  (bufferC (3) 1)
  (notC (3) 1)
  (bufferC (4) 1)
  (notC (4) 1)
  (bufferC (0) 2)
  (notC (0) 2)
  (bufferC (1) 2)
  (notC (1) 2)
  (bufferC (2) 2)
  (notC (2) 2)
  (bufferC (3) 2)
  (notC (3) 2)
  (bufferC (4) 2)
  (notC (4) 2)
  (bufferC (0) 3)
  (notC (0) 3)
  (bufferC (1) 3)
  (notC (1) 3)
  (bufferC (2) 3)
  (notC (2) 3)
  (bufferC (3) 3)
  (notC (3) 3)
  (bufferC (4) 3)
  (notC (4) 3)
  (bufferC (0) 4)
  (notC (0) 4)
  (bufferC (1) 4)
  (notC (1) 4)
  (bufferC (2) 4)
  (notC (2) 4)
  (bufferC (3) 4)
  (notC (3) 4)
  (bufferC (4) 4)
  (notC (4) 4)
  (andC (0 1) 0)
  (orC (0 1) 0)
  (xorC (0 1) 0)
  (nandC (0 1) 0)
  (andC (0 2) 0)
  (orC (0 2) 0)
  (xorC (0 2) 0)
  (nandC (0 2) 0)
  (andC (0 3) 0)
  (orC (0 3) 0)
  (xorC (0 3) 0)
  (nandC (0 3) 0)
  (andC (1 2) 0)
  (orC (1 2) 0)
  (xorC (1 2) 0)
  (nandC (1 2) 0)
  (andC (1 3) 0)
  (orC (1 3) 0)
  (xorC (1 3) 0)
  (nandC (1 3) 0)
  (andC (2 3) 0)
  (orC (2 3) 0)
  (xorC (2 3) 0)
  (nandC (2 3) 0)
  (andC (0 1) 1)
  (orC (0 1) 1)
  (xorC (0 1) 1)
  (nandC (0 1) 1)
  (andC (0 2) 1)
  (orC (0 2) 1)
  (xorC (0 2) 1)
  (nandC (0 2) 1)
  (andC (0 3) 1)
  (orC (0 3) 1)
  (xorC (0 3) 1)
  (nandC (0 3) 1)
  (andC (1 2) 1)
  (orC (1 2) 1)
  (xorC (1 2) 1)
  (nandC (1 2) 1)
  (andC (1 3) 1)
  (orC (1 3) 1)
  (xorC (1 3) 1)
  (nandC (1 3) 1)
  (andC (2 3) 1)
  (orC (2 3) 1)
  (xorC (2 3) 1)
  (nandC (2 3) 1)
  (andC (0 1) 2)
  (orC (0 1) 2)
  (xorC (0 1) 2)
  (nandC (0 1) 2)
  (andC (0 2) 2)
  (orC (0 2) 2)
  (xorC (0 2) 2)
  (nandC (0 2) 2)
  (andC (0 3) 2)
  (orC (0 3) 2)
  (xorC (0 3) 2)
  (nandC (0 3) 2)
  (andC (1 2) 2)
  (orC (1 2) 2)
  (xorC (1 2) 2)
  (nandC (1 2) 2)
  (andC (1 3) 2)
  (orC (1 3) 2)
  (xorC (1 3) 2)
  (nandC (1 3) 2)
  (andC (2 3) 2)
  (orC (2 3) 2)
  (xorC (2 3) 2)
  (nandC (2 3) 2)
  (andC (0 1) 3)
  (orC (0 1) 3)
  (xorC (0 1) 3)
  (nandC (0 1) 3)
  (andC (0 2) 3)
  (orC (0 2) 3)
  (xorC (0 2) 3)
  (nandC (0 2) 3)
  (andC (0 3) 3)
  (orC (0 3) 3)
  (xorC (0 3) 3)
  (nandC (0 3) 3)
  (andC (1 2) 3)
  (orC (1 2) 3)
  (xorC (1 2) 3)
  (nandC (1 2) 3)
  (andC (1 3) 3)
  (orC (1 3) 3)
  (xorC (1 3) 3)
  (nandC (1 3) 3)
  (andC (2 3) 3)
  (orC (2 3) 3)
  (xorC (2 3) 3)
  (nandC (2 3) 3)
  (andC (0 1) 4)
  (orC (0 1) 4)
  (xorC (0 1) 4)
  (nandC (0 1) 4)
  (andC (0 2) 4)
  (orC (0 2) 4)
  (xorC (0 2) 4)
  (nandC (0 2) 4)
  (andC (0 3) 4)
  (orC (0 3) 4)
  (xorC (0 3) 4)
  (nandC (0 3) 4)
  (andC (1 2) 4)
  (orC (1 2) 4)
  (xorC (1 2) 4)
  (nandC (1 2) 4)
  (andC (1 3) 4)
  (orC (1 3) 4)
  (xorC (1 3) 4)
  (nandC (1 3) 4)
  (andC (2 3) 4)
  (orC (2 3) 4)
  (xorC (2 3) 4)
  (nandC (2 3) 4))))

(define (eval-gate gate state)
  (map (lambda (outIdx) (if (eq? (gate-destidx gate) outIdx)
                          (apply (gate-fn gate) (map (curry list-ref state)
                                               (gate-argindices gate)))
                          (list-ref state outIdx)))
       indices))

(define (eval-circ circ state) (foldl eval-gate state circ))

(define (gate-idx-list-to-circ gateidxs)
  (map (curry list-ref gates) gateidxs))

(define maxGateIdx (length gates))

(define-symbolic* gateindices integer? #:length 5)

(define result-map '(
                     ((#f #f #f #t #f) (#t #f #f #f #f))
                     ((#t #f #f #f #f) (#f #t #f #f #f))
                     ((#t #t #f #f #f) (#f #f #t #f #f))
                     ((#f #t #t #f #f) (#f #f #f #t #f))
                     ((#f #f #t #t #f) (#f #f #f #f #t))
                     ))

(solve (assert
        (andmap (lambda (inp-outp-pair)
                  (eq?
                   (eval-circ
                    (gate-idx-list-to-circ gateindices)
                    (first inp-outp-pair))
                   (second inp-outp-pair)))
                result-map)))


;
;(eval-circ gates '(#f #f #f #f))